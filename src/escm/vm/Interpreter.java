// Author: Jordan Randleman - escm.vm.Interpreter
// Purpose:
//    Wrapper class containing the EScheme bytecode interpreter logic.
//    Invoke via "Interpreter.run()".

package escm.vm;
import java.util.ArrayList;
import java.util.ArrayDeque;
import java.util.Collections;
import escm.type.Datum;
import escm.type.Keyword;
import escm.type.Character;
import escm.type.number.Real;
import escm.type.procedure.types.TypeAlias;
import escm.util.error.Exceptionf;
import escm.util.Trampoline;
import escm.vm.type.callable.Callable;
import escm.vm.util.Instruction;
import escm.vm.util.ExecutionState;
import escm.vm.util.ObjectAccessChain;

public class Interpreter {
  ////////////////////////////////////////////////////////////////////////////
  // Application helper
  private static Trampoline.Bounce executeApplication(ArrayDeque<Datum> stack, int applicationItemCount, Trampoline.Continuation continuation) throws Exception {
    if(applicationItemCount == 0)
      throw new Exception("VM: Invalid \"call\" instruction, application count is 0");
    // Extract application items
    int absCount = Math.abs(applicationItemCount);
    Datum procedure = null;
    ArrayList<Datum> args = new ArrayList<Datum>(absCount-1);
    try {
      if(applicationItemCount < 0) {
        procedure = stack.pop();
        for(int i = 0; i < absCount-1; ++i)
          args.add(stack.pop());
      } else {
        for(int i = absCount-2; i >= 0; --i)
          args.add(stack.pop());
        Collections.reverse(args);
        procedure = stack.pop();
      }
    } catch(java.util.EmptyStackException e) {
      throw new Exceptionf("VM: Insufficient args for \"call\" instruction (need %d have %d)!", absCount, ((procedure == null) ? 0 : 1) + args.size());
    }
    
    // Validate procedure as such
    if(!(procedure instanceof Callable))
      throw new Exceptionf("VM: Invalid \"call\" instruction, applying non-callable %s", procedure.profile());

    // Return the application's result
    return ((Callable)procedure).callWith(args,continuation);
  }


  ////////////////////////////////////////////////////////////////////////////
  // Core interpretation loop
  // => PRECONDITION: <state.instructions> was generated by the assembler
  // => CVR = current value register, CII = current instruction index
  // => Trampolines continuations!
  public static Trampoline.Bounce run(ExecutionState state, Trampoline.Continuation continuation) throws Exception {
    int totalInstructions = state.instructions.size();
    while(state.cii < totalInstructions) {
      if(state.cii < 0) state.cii = 0;
      Instruction instruction = state.instructions.get(state.cii);
      switch(instruction.operation) {
        //////////////////////////////////////////////////////////////////////
        // (define <symbol>)
        case Instruction.DEFINE: {
          if(instruction.argument instanceof escm.type.Symbol) {
            state.env.define((escm.type.Symbol)instruction.argument,state.cvr);
          } else { // instruction.argument instanceof ObjectAccessChain
            ((ObjectAccessChain)instruction.argument).define(state,state.cvr);
          }
          state.cvr = escm.type.Void.VALUE;
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (set! <symbol>)
        case Instruction.SET: {
          if(instruction.argument instanceof escm.type.Symbol) {
            state.env.set((escm.type.Symbol)instruction.argument,state.cvr);
          } else { // instruction.argument instanceof ObjectAccessChain
            ((ObjectAccessChain)instruction.argument).set(state,state.cvr);
          }
          state.cvr = escm.type.Void.VALUE;
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (defined? <symbol>)
        case Instruction.DEFINEDP: {
          if(instruction.argument instanceof escm.type.Symbol) {
            state.cvr = escm.type.bool.Boolean.valueOf(state.env.has((escm.type.Symbol)instruction.argument));
          } else { // instruction.argument instanceof ObjectAccessChain
            state.cvr = escm.type.bool.Boolean.valueOf(((ObjectAccessChain)instruction.argument).has(state));
          }
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (define-type <symbol>)
        case Instruction.DEFINE_TYPE: {
          if(!(state.cvr instanceof Keyword))
            throw new Exceptionf("VM: Invalid \"define-type\" instruction, non-keyword CVR %s", state.cvr.profile());
          String aliasName;
          if(instruction.argument instanceof escm.type.Symbol) {
            escm.type.Symbol argSym = (escm.type.Symbol)instruction.argument;
            state.env.define(argSym,new TypeAlias(state.env,(Keyword)state.cvr));
            aliasName = argSym.value();
          } else { // instruction.argument instanceof ObjectAccessChain
            ObjectAccessChain argObj = (ObjectAccessChain)instruction.argument;
            argObj.define(state,new TypeAlias(state.env,(Keyword)state.cvr));
            aliasName = argObj.toChainString();
          }
          if(TypeAlias.isCyclic(state.env,aliasName))
            throw new Exceptionf("VM: Invalid \"define-type\" cyclic instruction: (define-type %s %s)", aliasName, state.cvr.write());
          state.cvr = escm.type.Void.VALUE;
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (ifn <integer>)
        case Instruction.IFN: {
          if(state.cvr.isTruthy()) {
            ++state.cii;
          } else {
            state.cii += ((Character)instruction.argument).value(); // we wrap java <int>s in escm <Character>s
          }
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (jump <integer>)
        case Instruction.JUMP: {
          state.cii += ((Character)instruction.argument).value(); // we wrap java <int>s in escm <Character>s
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (quote <symbol>)
        case Instruction.QUOTE: {
          state.cvr = instruction.argument.quote(state);
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (load <datum>)
        case Instruction.LOAD: {
          state.cvr = instruction.argument.loadWithState(state);
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (call <datum>)
        case Instruction.CALL: {
          state.cvr = instruction.argument.loadWithState(state);
          ++state.cii;
          if(!(state.cvr instanceof Real) || !((Real)state.cvr).isInteger())
            throw new Exceptionf("VM: Invalid \"call\" instruction, non-integer count %s", state.cvr.profile());
          return executeApplication(
            state.stack,
            ((Real)state.cvr).intValue(),
            (value) -> () -> Interpreter.run(state.getContinuationState(value),continuation)
          );
        }

        //////////////////////////////////////////////////////////////////////
        // (push) (push <datum>)
        case Instruction.PUSH: {
          if(instruction.argument == null) {
            state.stack.push(state.cvr);
          } else {
            state.stack.push(instruction.argument.loadWithState(state));
          }
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (pop)
        case Instruction.POP: {
          if(state.stack.size() == 0)
            throw new Exception("VM: Invalid \"pop\" instruction, stack is empty!");
          state.cvr = state.stack.pop();
          ++state.cii;
          break;
        }

        //////////////////////////////////////////////////////////////////////
        // (return) (return <datum>)
        case Instruction.RETURN: {
          if(instruction.argument == null) {
            return () -> continuation.run(state.cvr);
          } else {
            return () -> continuation.run(instruction.argument.loadWithState(state));
          }
        }

        //////////////////////////////////////////////////////////////////////
        // Invalid instruction!
        default: {
          throw new Exceptionf("VM: Invalid instruction index %d!", state.cii);
        }
      }
    }
    Datum finalCvrValue = state.cvr;
    return () -> continuation.run(finalCvrValue);
  }
}