[{
  "name": "object-oriented-programming",
  "aliases": ["oop"],
  "signatures": null,
  "description": "EScheme has a totally optional object system. See the <class> 'help' entry\nfor more nitty-gritty usage details, and <meta-object> for type details.\n\nAt a high-level, EScheme supports classes and interfaces. Like Java, there's\nsingle inheritance for classes and multiple inheritance for interfaces.\n\nReflection is done via OO primitives, often prefixed with 'oo-'.\n\nDot-notation for property access is supported even at the bytecode level,\nhence (define obj.property) is a valid instruction!\n\nAgain, check out <class>'s 'help' entry for more usage details :)",
  "example": null
}, {
  "name": "concurrency",
  "aliases": null,
  "signatures": null,
  "description": "EScheme supports parallelism via true Java threads!\n\nIts core literal data structures are immutable (including lists,\nin a departure from standard Scheme), however, objects generated\nfrom classes can be mutated (meaning one could create mutable\nlists via the object system!).\n\nSpawn threads via the <thread> procedure.\nGet a reentrant lock via the <mutex> procedure.\nCheck out <help>'s 'Procedures > Concurrency' section for more!\n\nOn Threading & Continuations:\n* Threads each have their own stack, and hence their own set of continuations.\n* Continuations are delimited by the execution of the thread that created them.\n* Hence a child thread's continuation will never 'continue' back into the parent\n  thread, rather, it will terminate where the child thread terminated.\n\nOn Threading & Dynamic Environments:\n* Each thread has a so-called 'dynamic environment', wherein a set of variable\n  bindings is kept globally within the thread while being hidden from other threads.\n* After querying for a variable that doesn't exist in a thread's dynamic environment,\n  the 'meta thread''s dynamic environment is checked. If an entry is found in the\n  meta thread's dynamic environment, a local copy is cached into the current thread's\n  dynamic environment and the querying operation continues.\n* This allows for us to have 'environment-global-thread-local' variables! State can\n  be shared & operated upon by many procedures without having to lock, since each\n  thread only ever operates on a local copy of the state!\n  => This is used by <dynamic-wind> in order to maintain thread-local winds!",
  "example": null
}, {
  "name": "comments",
  "aliases": null,
  "signatures": null,
  "description": "Single-line comments start with ';'.",
  "example": null
}, {
  "name": "macros",
  "aliases": null,
  "signatures": null,
  "description": "EScheme's macros expand at compile time, and are bound at runtime.\n\nA set of symbolic names and procedures tracked by the compiler, macros\nare defined in the global environment, and hence are shared across threads.\nMacros may be deleted for localization.\n\nCreated by 'define-syntax', being bound to procedures means that macros can\nuse the full power of EScheme at compile time. Furthermore, they may have\nmultiple arities, support optional arguments, and have variadic arguments\njust like any other EScheme procedure!\n\nMacros are so important in fact, their expansion is one of the only 4 jobs\nthat EScheme's Java11 compiler performs:\n\n  1. Identify and expand macros\n  2. Reflect inlined bytecode from 'bytecode'\n  3. Compile vector/hashmap literals\n  4. Compile function/macro applications\n\nThat's it! Every single other special form besides 'bytecode' is implemented\nas a macro (with the core special forms defined directly in inlined bytecode\ninstructions after being compiled by hand)!",
  "example": null
}, {
  "name": "command-line",
  "aliases": ["cmd-line", "cmdline", "commandline"],
  "signatures": null,
  "description": "Command-line flags may be used to modify EScheme's behavior:\n  1. -v, --version                  | Print EScheme version information\n  2. -h, --help                     | Print this information\n  3. -q, --quiet                    | Launch the REPL without ASCII art\n  4. -l, --load <script> <arg1> ... | Load <script> with <arg> ... as *argv* into the REPL\n  5. <script> <arg1> ...            | Interpret <script> with <arg> ... as *argv*\n  6. [no arguments]                 | Launch the REPL",
  "example": null
}, {
  "name": "continuation-passing-style",
  "aliases": ["continuations", "continuation", "cps"],
  "signatures": null,
  "description": "A style of programming which explicitly handles control flow via 'continuations',\nwhere a 'continuation' represents the rest of the work to be done in a program.\n\nProgramming with and manipulating continuations can yield certain advantages,\nmost notably the ability to implement many control flow operations in terms\nof continuations (including coroutines, try-catch, arbitrary returns, etc.)\n\nUnfortunately, explicitly programming with continuations is rarely desirable\nand hardly enjoyable. Fortunately, there are ways to convert any program into\nCPS, and Scheme as a language has this transformation baked in by default.\n\nThe power of continuations in Scheme may be leveraged through the primitive\n\"call/cc\" procedure: taking an unary procedure as its argument, \"call/cc\"\n(or \"call-with-current-continuation\") passes the current continuation as a\nunary-procedure argument to the function it received.\n\nNote that, when developing a runtime system, you actually have two means by\nwhich to go about implementing continuations. You can either transform the\nScheme into continuation passing style, or you could write the VM itself in\nCPS such that the continuation management is entirely handled internally.\n\nEScheme opts for the second approach. Note that it required a custom\ntrampolining library for this to work, since Java11 still doesn't implement\ntail-call optimizations, but oh well.\n\nOur baked-in VM-level continuations give us some serious advantages:\n\n  1. The bytecode is continuation-agnostic, since 'call/cc' is just like any\n     other procedure (this makes writing inlined bytecode MUCH simpler)\n  2. All function calls are 'call-optimized': since I both (a) implemented\n     trampolining for the Java tail-calls themselves, and (b) wrote the Java\n     code in CPS (thereby making every function call a tail-call).\n  3. Compiled procedure body bytecodes are MUCH shorter, since they don't\n     need to reflect the continuation-management logic already done by the VM.",
  "example": null
}, {
  "name": "serialization",
  "aliases": null,
  "signatures": null,
  "description": "Serialize EScheme code with the <serialize> primitive.\nLoad serialized EScheme code with the <load> primitive.\n\nSerialization works by storing the Java bytecode of the assembled instruction\nset object holding <escm-file-path>'s EScheme bytecode in <serialized-file-path>.\nThe contents must first be evaluated in order to expand macros properly during\ncompilation.\n\nTotally optional to use, this facility is provided in order to squeeze the most\nperformance out of the EScheme runtime, since loading a serialized file skips\nboth reading and compiling the EScheme code therein, making its overall evaluation\nfaster.\n\nAll EScheme objects serialize just as you'd imagine, save for Threads and Ports.\nBy default, Java doesn't enable these items to be serialized since they rely on\nsystem-dependant components that don't translate to a different machine's processes.\nHowever, EScheme allows such to occur using the following rules:\n\n  1. Threads\n     * Threads serialize to their default, \"pre-run\" state. This means that\n       serialized threads save their name and runnable-callable. It does _NOT_\n       save any information about the executing sub-process if serialized mid-run.\n  2. Output-Ports\n     * Output-Ports serialize their absolute file path, and always deserialize\n       without appending (as if created via <open-output-file>).\n       - This is because deserialization re-loads the entire script containing\n         the port, and hence any writing operations conducted by the script ought\n         to reoccur during the script's loading process.\n     * Hence Output-Ports _MUST_ be serialized & deserialized on a machine with the\n       same directory layout, to avoid errors with the stored absolute-path!\n  3. Input-Ports\n     * Input-Ports serialize their absolute file path, and always deserialize with\n       their current line & column both set to 1 (reading from the start of the file).\n     * Hence Input-Ports _MUST_ be serialized & deserialized on a machine with the\n       same directory layout, to avoid errors with the stored absolute-path!\n\nOF NOTE: The semantics of thread/port serialization won't be an issue for 99.99999%\n*******  of serialized programs that use macros in a remotely sane way.\n\n         Only by intentionally returning a value that contains an initialized thread\n         or port datum from a macro can one tease out this behavior.\n\n         Given that most macros only return code as data structures (rather than\n         data values), these semantics are only something worth thinking about\n         if you're intentionally employing some genuinely tricky (& almost\n         certainly questionable) EScheme meta-programming techniques.",
  "example": null
}]