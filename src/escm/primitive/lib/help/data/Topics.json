[
  {
    "name": "object-system",
    "description": "EScheme has a totally optional object system. See the <class> 'help' entry\nfor more nitty-gritty usage details, and <meta-object> in <Intrinsic-Types> for\ntype details.\n\nAt a high-level, EScheme supports classes and interfaces. Like Java, there's\nsingle inheritance for classes and multiple inheritance for interfaces.\n\nReflection is done via OO primitives, often prefixed with 'oo-'.\n\nDot-notation for property access is supported even at the bytecode level,\nhence (define obj.property) is a valid instruction!\n\nAgain, check out <class>'s 'help' entry for more usage details :)"
  },
  {
    "name": "concurrency",
    "description": "EScheme supports parallelism via true Java threads!\n\nIts core literal data structures are immutable (including lists,\nin a departure from standard Scheme), however, objects generated\nfrom classes can be mutated (meaning one could create mutable\nlists via the object system!).\n\nSpawn threads via the <thread> procedure.\nGet a reentrant lock via the <mutex> procedure.\nCheck out <help>'s 'Procedures > Concurrency' section for more!\n\nOn Threading & Continuations:\n* Threads each have their own stack, and hence their own set of continuations.\n* Continuations are delimited by the execution of the thread that created them.\n* Hence a child thread's continuation will never 'continue' back into the parent\n  thread, rather, it will terminate where the child thread terminated.\n\nOn Threading & Dynamic Environments:\n* Each thread has a so-called 'dynamic environment', wherein a set of variable\n  bindings is kept globally within the thread while being hidden from other threads.\n* After querying for a variable that doesn't exist in a thread's dynamic environment,\n  the 'meta thread''s dynamic environment is checked. If an entry is found in the\n  meta thread's dynamic environment, a local copy is cached into the current thread's\n  dynamic environment and the querying operation continues.\n* This allows for us to have 'environment-global-thread-local' variables! State can\n  be shared & operated upon by many procedures without having to lock, since each\n  thread only ever operates on a local copy of the state!\n  => This is used by <dynamic-wind> in order to maintain thread-local winds!"
  },
  {
    "name": "comments",
    "description": "Single-line comments start with ';'."
  },
  {
    "name": "macros",
    "description": "EScheme's macros expand at compile time, and are bound at runtime.\n\nA set of symbolic names and procedures tracked by the compiler, macros\nare defined in the global environment, and hence are shared across threads.\nThey are not, however, shared across modules!\n\nCreated by 'define-syntax', being bound to procedures means that macros can\nuse the full power of EScheme at compile time. Furthermore, they may have\nmultiple arities, support optional arguments, and have variadic arguments\njust like any other EScheme procedure!\n\nMacros are so important in fact, their expansion is one of the only 4 jobs\nthat EScheme's Java11 compiler performs:\n\n  1. Reflect inlined bytecode from 'bytecode'\n  2. Compile vector/hashmap literals\n  3. Identify and expand macros\n  4. Compile function applications\n\nThat's it! Every single other special form besides 'bytecode' is implemented\nas a macro!"
  },
  {
    "name": "command-line",
    "description": "Command-line flags may be used to modify EScheme's behavior:\n  1. -v, --version                  | Print EScheme version information\n  2. -h, --help                     | Print this information\n  3. -q, --quiet                    | Launch the REPL without ASCII art\n  4. -l, --load <script> <arg1> ... | Load <script> with <arg> ... as *argv* into the REPL\n  5. -i, --import <module> <arg1> ... | Import <module> with <arg> ... as *argv* into the REPL\n  6. <script> <arg1> ...            | Interpret <script> with <arg> ... as *argv*\n  7. [no arguments]                 | Launch the REPL"
  },
  {
    "name": "continuation-passing-style",
    "description": "A style of programming which explicitly handles control flow via 'continuations',\nwhere a 'continuation' represents the rest of the work to be done in a program.\n\nProgramming with and manipulating continuations can yield certain advantages,\nmost notably the ability to implement many control flow operations in terms\nof continuations (including coroutines, try-catch, arbitrary returns, etc.)\n\nUnfortunately, explicitly programming with continuations is rarely desirable\nand hardly enjoyable. Fortunately, there are ways to convert any program into\nCPS, and Scheme as a language has this transformation baked in by default.\n\nThe power of continuations in Scheme may be leveraged through the primitive\n\"call/cc\" procedure: taking an unary procedure as its argument, \"call/cc\"\n(or \"call-with-current-continuation\") passes the current continuation as a\nunary-procedure argument to the function it received.\n\nNote that, when developing a runtime system, you actually have two means by\nwhich to go about implementing continuations. You can either transform the\nScheme into continuation passing style, or you could write the VM itself in\nCPS such that the continuation management is entirely handled internally.\n\nEScheme opts for the second approach. Note that it required a custom\ntrampolining library for this to work, since Java11 still doesn't implement\ntail-call optimizations, but oh well.\n\nOur baked-in VM-level continuations give us some serious advantages:\n\n  1. The bytecode is continuation-agnostic, since 'call/cc' is just like any\n     other procedure (this makes writing inlined bytecode MUCH simpler)\n  2. All function calls are 'call-optimized': since I both (a) implemented\n     trampolining for the Java tail-calls themselves, and (b) wrote the Java\n     code in CPS (thereby making every function call a tail-call).\n  3. Compiled procedure body bytecodes are MUCH shorter, since they don't\n     need to reflect the continuation-management logic already done by the VM."
  },
  {
    "name": "serialization",
    "description": "Serialize EScheme code with the <serialize> primitive.\nLoad serialized EScheme code with the <load> primitive.\n\nSerialization works by storing the Java bytecode of the assembled instruction\nset object holding <escm-file-path>'s EScheme bytecode in <serialized-file-path>.\nThe contents must first be evaluated in order to expand macros properly during\ncompilation.\n\nTotally optional to use, this facility is provided in order to serve as a portable \nobfuscation tactic to generate a rough equivalent to \"EScheme binaries\". \n\nHowever, it is important to note that - strangely enough - serialized files tend to \nload _SLOWER_ than regular EScheme files. Despite allowing us to circumvent the \nreading, compilation, and assembly of EScheme code, it turns out that EScheme's \nfacilities to do so are all actually so fast as to beat out Java's native \ndeserialization functions!\n\nHence, only serialize your EScheme code if you'd like to make the file unreadable\nfor humans.\n\nAll EScheme objects serialize just as you'd imagine, save for Threads and Ports.\nBy default, Java doesn't enable these items to be serialized since they rely on\nsystem-dependant components that don't translate to a different machine's processes.\nHowever, EScheme allows such to occur using the following rules:\n\n  1. Threads\n     * Threads serialize to their default, \"pre-run\" state. This means that\n       serialized threads save their name and runnable-callable. It does _NOT_\n       save any information about the executing sub-process if serialized mid-run.\n  2. Output-Ports\n     * Output-Ports serialize their absolute file path, and always deserialize\n       without appending (as if created via <open-output-file>).\n       - This is because deserialization re-loads the entire script containing\n         the port, and hence any writing operations conducted by the script ought\n         to reoccur during the script's loading process.\n     * Hence Output-Ports _MUST_ be serialized & deserialized on a machine with the\n       same directory layout, to avoid errors with the stored absolute-path!\n  3. Input-Ports\n     * Input-Ports serialize their absolute file path, and always deserialize with\n       their current line & column both set to 1 (reading from the start of the file).\n     * Hence Input-Ports _MUST_ be serialized & deserialized on a machine with the\n       same directory layout, to avoid errors with the stored absolute-path!\n\nOF NOTE: The semantics of thread/port serialization won't be an issue for 99.99999%\n*******  of serialized programs that use macros in a remotely sane way.\n\n         Only by intentionally returning a value that contains an initialized thread\n         or port datum from a macro can one tease out this behavior.\n\n         Given that most macros only return code as data structures (rather than\n         data values), these semantics are only something worth thinking about\n         if you're intentionally employing some genuinely tricky (& almost\n         certainly questionable) EScheme meta-programming techniques."
  },
  {
    "name": "type-system",
    "description": "# Types in EScheme\n\n### Describes EScheme's optional type system!\n\n## Overview\n\nEScheme denotes types with keywords, and \"union types\" via `|` syntax.\n\n- EX: `:string|number` represents either a string or a number.\n\nEScheme types are typically either a \"primitive\" or \"container\" type.\nIf a type is neither a primitive nor a container, it is presumed to\nrepresent some class, interface, or type-alias: if the type doesn't\nresolve to a valid class, interface, or type-alias during a runtime\ntype-check, an error is thrown.\n\n- Note that EScheme supports referencing classes/interfaces/aliases\n  in modules! Hence `:Module.ClassName` is a valid type.\n\nEScheme types are parsed and converted to Java functional interface\npredicates internally during compilation, with the predicates being\napplied at runtime. Types are supported for function parameters and\nreturn values.\n\n### EScheme Primitive Types\n\nPrimitive types represent an intrinsic atomic EScheme type. Their\ntype-checks are typically as fast as a single `instanceof` check,\nwith a few exceptions like `:int` requiring slightly more work.\n\nEScheme's primitive types include:\n\n```\n:any\n\n:number ; aliased by \":complex\"\n:int\n:flo\n:real\n:exact\n:inexact\n\n:string\n:char\n:key\n:bool\n:symbol\n:void\n\n:thread\n:mutex\n\n:nil\n:atom\n\n:fn ; all callables\n:procedure\n:syntax\n\n:metaobj ; includes objects, classes, interfaces, and modules\n:object\n:class\n:interface\n\n:port\n:inport\n:outport\n\n:module\n\n:type-alias\n```\n\n### EScheme Container Types\n\nContainer types represent an intrinsic EScheme collection type. By\ndefault, collections are just checked to match whatever type of\ncollection the keyword stands for (without regard for the types of\nits contents). However, containers may be parameterized by adding\nthe `<type>` suffix in order to type-check its contents as well.\n\nFor example, `:list<string|symbol>` is a list where each element is\neither a string or symbol.\n\n- For either a list that only has strings OR a list that only has\n  symbols, use `:list<string>|list<symbol>`.\n- Furthermore, `:pair` and `:map` may also be parameterized with the\n  `<type,type>` suffix in order to type-check their keys and values.\n\nEScheme's collection types include:\n\n```\n:vector\n:map\n\n:pair\n:list\n\n:associative-collection ; aliased by \":ac\"\n:ordered-collection ; aliased by \":oc\"\n```\n\n---\n\n## Type Syntax Examples\n\nNotes on optional and variadic parameters:\n\n- Optional parameters only type-check user args, _not_ their default values\n  - Hence `(:int a \"hello\")` is a valid optional parameter clause\n- Variadic values cannot be typed (they're implicitly `:list<any>`)\n\n### `fn` and `defn`\n\n- `defn` uses the same type syntax as `fn`\n\n```\n(fn\n  ; Typed <:int> return and <:list>/<:char> parameters\n  (:int (:list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Typeless return, required <:flo> parameter and optional <:int> parameter\n  ((:flo a (:int b 42))\n    (+ a b)))\n\n\n(defn function-name\n  ; Typed <:int> return and <:list>/<:char> parameters\n  (:int (:list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Typeless return, required <:flo> and optional <:int> parameters\n  ((:flo a (:int b 42))\n    (+ a b)))\n```\n\n### `lambda`\n\n```\n; Typed <:int> return and <:list>/<:char> parameters\n(lambda :int (:list a :char b . rest-args)\n  (length (cons b (cons a rest-args))))\n\n; Typeless return, required <:flo> and optional <:int> parameters\n(lambda (:flo a (:int b 42))\n  (+ a b))\n```\n\n### `define`\n\n```\n; Typed <:int> return and <:list>/<:char> parameters\n(define :int (function-name :list a :char b . rest-args)\n  (length (cons b (cons a rest-args))))\n\n; Typeless return, required <:flo> and optional <:int> parameters\n(define (function-name :flo a (:int b 42))\n  (+ a b))\n```\n\n### `define-generator`\n\n- Only supports typed parameters, not typed returns, to account for\n  `*generator-complete*` being returned from finite generators.\n\n```\n; Required <:flo> and optional <:int> parameters\n(define-generator (generator-factory-name :flo a (:int b 42))\n  (let loop ((i b))\n    (yield (+ i a))\n    (loop (+ i 1))))\n```\n\n### `curry`\n\n- Only type-checks the return value once all parameters have been applied.\n\n```\n; Typed <:int> return and <:list>/<:char> parameters\n(curry :int (:list a :char b)\n  (length (cons b a)))\n```\n\n### `class`/`define-class` and `interface`/`define-interface`\n\n- `class` supports types on instance and static methods\n- `interface` only supports types on static methods\n- `define-class` uses the same type syntax as `class`\n  - as `define-interface` does with `interface`\n\n```\n(define-class ClassName\n  ; Instance: typed <:int> return and <:list>/<:char> parameters\n  (:int (method-name-1 :list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Instance: typeless return, required <:flo> and optional <:int> parameters\n  ((method-name-2 :flo a (:int b 42))\n    (+ a b))\n\n  ; Static: typed <:int> return and <:list>/<:char> parameters\n  (:static :int (method-name-1 :list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Static: typeless return, required <:flo> and optional <:int> parameters\n  (:static (method-name-2 :flo a (:int b 42))\n    (+ a b)))\n\n\n(define-interface InterfaceName\n  ; Static: typed <:int> return and <:list>/<:char> parameters\n  (:static :int (method-name-1 :list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Static: typeless return, required <:flo> and optional <:int> parameters\n  (:static (method-name-2 :flo a (:int b 42))\n    (+ a b)))\n\n\n; Mandating that <function-name> returns either <ClassName> or <InterfaceName>\n(define :ClassName|InterfaceName (function-name)\n  (ClassName))\n```\n\n---\n\n## Type Aliases\n\nType aliases reference a preexisting keyword type, typically to\nmask type complexity. For example, when implementing a `UserProfile`\nclass, it might be nicer to define a `:phone-number` type instead of\nalways using `:string|list<int>`.\n\nType aliases can be created by using `define-type` (aliased by `deftype`)\nwhich is simply a convenience wrapper around `define` and `type-alias`.\n\n- `(type-alias <type-keyword>)` creates a type alias value\n- `(type-alias? <obj>)` returns whether `<obj>` is a type alias\n- `(type-alias-source <type-alias>)` returns the original keyword type\n  that `<type-alias>` references\n\n### Example\n\n```\n; Create a type-alias and dispatch on it\n(define-type phone-number :string|list<int>)\n\n(defn function-name\n  ((:phone-number x) #t)\n  ((:any x) #f))\n\n(function-name \"555-555-5555\") ; #t\n(function-name '(555 555 5555)) ; #t\n(function-name 5555555555) ; #f\n```\n\n---\n\n## Type Primitive\n\nUse `(type-is? <obj> <type-keyword>)` to determine if `<obj>` is a `<type-keyword>`."
  }
]
