[
  {
    "name": "object-system",
    "description": "# Objects in EScheme\n\n### Describes EScheme's optional object system!\n\n## Object System Overview\n\nEScheme has a totally optional object system, including support for:\n\n- Single inheritance for classes, multiple inheritance for interfaces\n- Static support:\n  - `:static` fields & methods for class/interface-local properties\n    - implied when `define`ing a new class/interface property!\n- `self` semantics:\n  - instance methods have `self` dynamically bound to the calling object\n  - static methods have `self` bound to the class datum they belong to\n- `super` semantics:\n  - instance methods have `super` statically bound to the super object\n  - static methods have `super` bound to the super class\n- Referring to static props in instance methods:\n  - `<classname>.<static-prop>`\n  - `self.class.<static-prop>`\n- Special object properties:\n  - `new` pseudo-method constructor syntax\n    - Doesn't correlate to an actual method named `new`\n  - `class` field to access the class of the current object\n  - `->procedure` method to overload application for objects\n    - Applicable objects with this method are called \"functor\"s\n- Special class and interface property:\n  - `name`: the symbolic name of the class/interface\n    - Only present if the class/interface is NOT anonymous!\n- All methods have the following variables automatically defined:\n  - `self` ; the polymorphic calling object\n  - `super` ; the super object if exists, else #f\n- Bytecode-level support for `(define obj.prop)` `(set! obj.prop)` syntax\n\n---\n\n## Named Class Syntax:\n\n### Also generates a `(<class-name>? <obj>)` predicate procedure!\n\n### May use `defclass` to alias `define-class`!\n\n(define-class <class-name>\n  (:extends <class>) (:implements <interface> ...) ; both are optional\n  <optional-docstring>\n  (:static <name> <value>)\n  (:static (<method-name> <param> ...) <body> ...)\n  (<name> <value>)\n  ((<method-name> <param> ...) <body> ...))\n\n---\n\n## Anonymous Class Syntax:\n\n(class (:extends <class>) (:implements <interface> ...) ; both are optional\n  <optional-docstring>\n  (:static <name> <value>)\n  (:static (<method-name> <param> ...) <body> ...)\n  (<name> <value>)\n  ((<method-name> <param> ...) <body> ...))\n\n---\n\n## Named Interface Syntax:\n\n### Also generates an `(<interface-name>? <obj>)` predicate procedure!\n\n### May use `definterface` to alias `define-interface`!\n\n(define-interface <interface-name>\n  (:extends <interface> ...) ; \":extends\" is optional\n  <optional-docstring>\n  (:static <name> <value>)\n  (:static (<method-name> <param> ...) <body> ...)\n  <name> ; required property name(s) for a class to have\n  ((<method-name> <param> ...))) ; required method signature(s) for a class to have\n\n---\n\n## Anonymous Interface Syntax:\n\n(interface (:extends <interface> ...) ; \":extends\" is optional\n  <optional-docstring>\n  (:static <name> <value>)\n  (:static (<method-name> <param> ...) <body> ...)\n  <name> ; required property name(s) for a class to have\n  ((<method-name> <param> ...))) ; required method signature(s) for a class to have\n\n---\n\n## Initializing Super Object Constructors\n\nThe `(super! <param> ...)` macro may be used within object constructors to\ninitialize an object's super class with a set of parameters.\n\n- Super objects with a \"nullary\" constructor are automatically constructed.\n- `super!` must be used immediately in constructors to avoid undefined behavior!\n- Use `(apply-super! <param-list>)` to initialize the super object with a list."
  },
  {
    "name": "concurrency",
    "description": "# Concurrency in EScheme\n\n### Describes EScheme's concurrency semantics!\n\n## Concurrency System Overview\n\nEScheme supports parallelism via true Java threads!\n\nIts core literal syntax uses immutable data structures (including lists\nand strings, in a departure from standard Scheme), however, objects\ngenerated from classes can be mutated (meaning one could create mutable\nlists via the object system!). Note that vectors and hashmaps are mutable\ntoo.\n\nIn addition to Java threads, EScheme also supports JavaScript's `Promise`\nconcurrency paradigm. For synchronization, EScheme exposes Java reentrant\nlocks via `mutex`, and supports Clojure's `dosync` macro!\n\n---\n\n## Using Concurrent Primitives\n\n- Spawn threads via the `thread` procedure.\n- Create promises via the `promise` procedure.\n- Get a reentrant lock via the `mutex` procedure.\n- Check out the `help` function's `Procedures > Concurrency` section for more!\n\n---\n\n## Threading and Continuations\n\n- Threads each have their own stack, and hence their own set of continuations.\n- Continuations are delimited by the execution of the thread that created them.\n  - Hence a child thread's continuation will never 'continue' back into the parent\n    thread, rather, it will terminate where the child thread terminated.\n\n---\n\n## Threading and Dynamic Environments\n\n- Each thread has a so-called 'dynamic environment', wherein a set of variable\n  bindings is kept globally within the thread while being hidden from other threads.\n  - Mutate a thread's dynamic environment via the `thread-define`, `thread-set!`,\n    and `thread-get` procedures!\n- After querying for a variable that doesn't exist in a thread's dynamic environment,\n  the 'meta thread''s dynamic environment is checked. If an entry is found in the\n  meta thread's dynamic environment, a local copy is cached into the current thread's\n  dynamic environment and the querying operation continues.\n- This allows for us to have 'environment-global-thread-local' variables! State can\n  be shared & operated upon by many procedures without having to lock, since each\n  thread only ever operates on a local copy of the state!\n  - This is used by `dynamic-wind` in order to maintain thread-local winds!"
  },
  {
    "name": "comments",
    "description": "Single-line comments start with ';'."
  },
  {
    "name": "macros",
    "description": "EScheme's macros expand at compile time, and are bound at runtime.\n\nA set of symbolic names and procedures tracked by the compiler, macros\nare defined in the global environment, and hence are shared across threads.\nThey are not, however, shared across modules!\n\nCreated by 'define-syntax', being bound to procedures means that macros can\nuse the full power of EScheme at compile time. Furthermore, they may have\nmultiple arities, support optional arguments, and have variadic arguments\njust like any other EScheme procedure!\n\nMacros are so important in fact, their expansion is one of the only 4 jobs\nthat EScheme's Java compiler performs:\n\n  1. Reflect inlined bytecode from 'bytecode'\n  2. Compile vector/hashmap literals\n  3. Identify and expand macros\n  4. Compile function applications\n\nThat's it! Every single other special form besides 'bytecode' is implemented\nas a macro!"
  },
  {
    "name": "module-system",
    "description": "# Modules in EScheme\n\n### Describes EScheme's optional module system!\n\n## Motivation and Overview\n\nThe value created by an `import` expression.\n\nModules present an alternative to Scheme's usual inter-file semantics.\n\nThe `load` function has always served as a means by which to execute the code\nof another Scheme file in the calling file's global environment. This simplicity\nis a double edged sword though: while making `load` easy to implement, it leaves\nmuch to be desired with respect to enabling encapsulation of code across\ncoordinated Scheme files.\n\nAs such, in addition to `load`, EScheme offers a minimalistic module system\nthat strives to enable file-specific encapsulation of EScheme code. Files\nprocessed via the `import` macro are defined as `module` objects within the\nenclosing enivironment. See the `import` details below for more information on\nhow EScheme evaluates modules.\n\nEach module has its own isolated global environment, and has automatic access\nto EScheme's standard library. Note that this means that operations that depend\non global variables (e.g. `load-once`) are hence only able to operate on\na module-relative basis.\n\n- Note that `dosync` notably works across modules, since its internal lock was\n  created via `define-parameter`. Use `dosync-module` for module-relative locking\n  behavior.\n\nBoth variables and macros can be accessed from a module by using EScheme's\ndot-notation: for example, to access variable `PersonClass` from module `Mod`,\nwe write `Mod.PersonClass`.\n\nFurther note that imported modules are cached! Importing the same module\nmultiple times does not cause multiple evaluations of that module. Use the\n`reload` macro if you'd like to forcefully re-evaluate the module in question.\n\nAdditionally, the `from` macro may be used to load specific variables within\na given module, without defining that module itself as a local variable.\n\nModules may be introspected upon by 2 primitives:\n\n1. `module-path`: yield the absolute file path to the module (this is what\n   distinguishes one module from another under the hood).\n2. `module-bindings`: yield a list of the symbols defined in a module (beware:\n   every module redefines the entire EScheme standard library!).\n\nNote that the 'meta-thread's environment (see `thread-define`) is module\nindependant!\n\nUse the `*import*` variable to determine if the current file was `import`ed.\nCan combine with `unless` to mimic Python's `if __name__=='__main__':` pattern:\n\n  (unless *import*\n    <execute-main-escheme-code-here> ...)\n\nLastly, note that the concept of 'parameter' variables exist in order to\nhave global state shared across modules. See the `define-parameter` and\n`parameter?` 'help' entries for more details.\n\n---\n\n## Accessing variable `<var>` from module `<module>`\n\n<module>.<var>\n\n---\n\n## Regular Imports\n\n(import <module-path-symbol>)\n(import <module-path-symbol> :as <module-alias-symbol>)\n(import <filepath-string> <module-path-symbol>)\n(import <filepath-string> <module-path-symbol> :as <module-alias-symbol>)\n\nImport `<module-path-symbol>` as a module variable in the current environment,\nwhere `<module-path-symbol>` represents an Escheme (or `serialize`d!) file.\nSeeks the module from `<filepath-string>`, if provided.\n\nModule variables are named `<module-path-symbol>` by default, though there are\n2 caveats:\n\n1.  `<module-alias-symbol>` is provided: this overrides the default name and\n    will be what the module is loaded into the environment as.\n\n2.  `<module-path-symbol>` is a dotted list of symbols: this is how we denote\n    access to a module that is in a different folder than the current\n    directory. For example, suppose we have the following directory layout:\n\n    Root\n    |____ Folder1\n    |     |_______ Module.scm\n    |\n    |____ Folder2\n          |_______ Main.scm\n    \n    For `Main.scm` to import `Module.scm`, it would contain:\n\n    (import Folder1.Module) ; within 'Main.scm'. '(import Root.Folder1.Module)' also works\n    \n    In this example, the module variable would be named `Module`. Note that\n    the file extension of the target module file is left out from the `import`\n    expression.\n\nWith regards to locating the file pointed to by `<module-path-symbol>`, EScheme\nwill first attempt to find it along the file path tree from the location that\ninvoked the `import` expression. Note that this makes executing `(import #path Module)`\nredundant, in contrast to the `load` function.\n\nImported modules are also cached across modules, so every instance of `(import Module)`\nwill reference the same `Module` module object. Note that you can force a module\nto be reloaded via the `reload` special form.\n\nSee the `from` details below for an alternative to `import` that extracts specific\nfields from the `<module-path-symbol>` module, without adding the module itself to\nyour current environment's namespace.\n\n---\n\n## Reloading Modules\n\n(reload <module-alias-symbol>)\n\nForcefully re-evaluate `<module-alias-symbol>` (note that `import` caches\nmodules by default).\n\n---\n\n## Loading Module Variables\n\n(from <module-path-symbol> :import <obj1-symbol> <obj2-symbol> ...)\n(from <module-path-symbol> :import <obj1-symbol> <obj2-symbol> ... :as <alias1-symbol> <alias2-symbol> ...)\n(from <filepath-string> <module-path-symbol> :import <obj1-symbol> <obj2-symbol> ...)\n(from <filepath-string> <module-path-symbol> :import <obj1-symbol> <obj2-symbol> ... :as <alias1-symbol> <alias2-symbol> ...)\n\nImport `<obj1-symbol> <obj2-symbol> ...` from `<module-path-symbol>`, without\nexposing the module itself as a variable within the current environment.\n\nEquivalent to:\n\n(begin\n  (import <module-path-symbol> :as <hidden-name>)\n  (define <obj1-symbol> <hidden-name>.<obj1-symbol>)\n  (define <obj2-symbol> <hidden-name>.<obj2-symbol>)\n  ...)\n\nOr, if `<alias1-symbol> ...` is provided:\n\n(begin\n  (import <module-path-symbol> :as <hidden-name>)\n  (define <alias1-symbol> <hidden-name>.<obj1-symbol>)\n  (define <alias2-symbol> <hidden-name>.<obj2-symbol>)\n  ...)\n\nIf given `<filepath-string>`, `from` simply adds it to the above `import`\nstatement.\n\n---\n\n## Module Introspection Primitives\n\n### Module Predicate\n\n(module? <obj>)\n\n### Module Absolute Path Source Location\n\n(module-path <module>)\n\nThe absolute file path string of the module file's location, what\ndistinguishes one module from another under the hood.\n\n### Module Variable Name Bindings List\n\n(module-bindings <module>)\n\nA list of variable symbols defined in `<module>`. Beware that all modules load\nall of EScheme's standard library by default!"
  },
  {
    "name": "command-line",
    "description": "Command-line flags may be used to modify EScheme's behavior:\n  1. -v, --version                    | Print EScheme version information\n  2. -h, --help                       | Print this information\n  3. -q, --quiet                      | Launch the REPL without ASCII art\n  4. -e, --eval <escheme code>        | Evaluate <escheme code> in a temporary file\n  5. -l, --load <script> <arg1> ...   | Load <script> with <arg> ... as *argv* into the REPL\n  6. -i, --import <module> <arg1> ... | Import <module> with <arg> ... as *argv* into the REPL\n  7. <script> <arg1> ...              | Interpret <script> with <arg> ... as *argv*\n  8. [no arguments]                   | Launch the REPL"
  },
  {
    "name": "continuation-passing-style",
    "description": "A style of programming which explicitly handles control flow via 'continuations',\nwhere a 'continuation' represents the rest of the work to be done in a program.\n\nProgramming with and manipulating continuations can yield certain advantages,\nmost notably the ability to implement many control flow operations in terms\nof continuations (including coroutines, try-catch, arbitrary returns, etc.)\n\nUnfortunately, explicitly programming with continuations is rarely desirable\nand hardly enjoyable. Fortunately, there are ways to convert any program into\nCPS, and Scheme as a language has this transformation baked in by default.\n\nThe power of continuations in Scheme may be leveraged through the primitive\n\"call/cc\" procedure: taking an unary procedure as its argument, \"call/cc\"\n(or \"call-with-current-continuation\") passes the current continuation as a\nunary-procedure argument to the function it received.\n\nNote that, when developing a runtime system, you actually have two means by\nwhich to go about implementing continuations. You can either transform the\nScheme into continuation passing style, or you could write the VM itself in\nCPS such that the continuation management is entirely handled internally.\n\nEScheme opts for the second approach. Note that it required a custom\ntrampolining library for this to work, since Java 21 still doesn't implement\ntail-call optimizations, but oh well.\n\nOur baked-in VM-level continuations give us some serious advantages:\n\n  1. The bytecode is continuation-agnostic, since 'call/cc' is just like any\n     other procedure (this makes writing inlined bytecode MUCH simpler)\n  2. All function calls are 'call-optimized': since I both (a) implemented\n     trampolining for the Java tail-calls themselves, and (b) wrote the Java\n     code in CPS (thereby making every function call a tail-call).\n  3. Compiled procedure body bytecodes are MUCH shorter, since they don't\n     need to reflect the continuation-management logic already done by the VM."
  },
  {
    "name": "serialization",
    "description": "Serialize EScheme code with the <serialize> primitive.\nLoad serialized EScheme code with the <load> primitive.\n\nSerialization works by storing the Java bytecode of the assembled instruction\nset object holding <escm-file-path>'s EScheme bytecode in <serialized-file-path>.\nThe contents must first be evaluated in order to expand macros properly during\ncompilation.\n\nTotally optional to use, this facility is provided in order to serve as a portable \nobfuscation tactic to generate a rough equivalent to \"EScheme binaries\". \n\nHowever, it is important to note that - strangely enough - serialized files tend to \nload _SLOWER_ than regular EScheme files. Despite allowing us to circumvent the \nreading, compilation, and assembly of EScheme code, it turns out that EScheme's \nfacilities to do so are all actually so fast as to beat out Java's native \ndeserialization functions!\n\nHence, only serialize your EScheme code if you'd like to make the file unreadable\nfor humans.\n\nAll EScheme objects serialize just as you'd imagine, save for Threads and Ports.\nBy default, Java doesn't enable these items to be serialized since they rely on\nsystem-dependant components that don't translate to a different machine's processes.\nHowever, EScheme allows such to occur using the following rules:\n\n  1. Threads\n     * Threads serialize to their default, \"pre-run\" state. This means that\n       serialized threads save their name and runnable-callable. It does _NOT_\n       save any information about the executing sub-process if serialized mid-run.\n  2. Output-Ports\n     * Output-Ports serialize their absolute file path, and always deserialize\n       without appending (as if created via <open-output-file>).\n       - This is because deserialization re-loads the entire script containing\n         the port, and hence any writing operations conducted by the script ought\n         to reoccur during the script's loading process.\n     * Hence Output-Ports _MUST_ be serialized & deserialized on a machine with the\n       same directory layout, to avoid errors with the stored absolute-path!\n  3. Input-Ports\n     * Input-Ports serialize their absolute file path, and always deserialize with\n       their current line & column both set to 1 (reading from the start of the file).\n     * Hence Input-Ports _MUST_ be serialized & deserialized on a machine with the\n       same directory layout, to avoid errors with the stored absolute-path!\n\nOF NOTE: The semantics of thread/port serialization won't be an issue for 99.99999%\n*******  of serialized programs that use macros in a remotely sane way.\n\n         Only by intentionally returning a value that contains an initialized thread\n         or port datum from a macro can one tease out this behavior.\n\n         Given that most macros only return code as data structures (rather than\n         data values), these semantics are only something worth thinking about\n         if you're intentionally employing some genuinely tricky (& almost\n         certainly questionable) EScheme meta-programming techniques."
  },
  {
    "name": "type-system",
    "description": "# Types in EScheme\n\n### Describes EScheme's optional type system!\n\n## Overview\n\nEScheme denotes types with keywords, and \"union types\" via `|` syntax.\n\n- EX: `:str|num` represents either a string or a number.\n\nEScheme types are typically either a \"primitive\" or \"collection\" type.\nIf a type is neither a primitive nor a collection, it is presumed to\nrepresent some class, interface, or type-alias: if the type doesn't\nresolve to a valid class, interface, or type-alias during a runtime\ntype-check, an error is thrown.\n\n- Note that EScheme supports referencing classes/interfaces/aliases\n  in modules! Hence `:Module.ClassName` is a valid type.\n\nEScheme types are parsed and converted to Java functional interface\npredicates internally during compilation, with the predicates being\napplied at runtime. Types are supported for function parameters and\nreturn values.\n\n### EScheme Primitive Types\n\nPrimitive types represent an intrinsic atomic EScheme type. Their\ntype-checks are typically as fast as a single `instanceof` check,\nwith a few exceptions like `:int` requiring slightly more work.\n\nEScheme's primitive types include:\n\n:any\n\n:num ; aliased by \":complex\"\n:int ; matches floats without fractionals too\n:flo\n:real\n:exact\n:inexact\n:bigint\n\n:str\n:char\n:key ; keyword\n:bool\n:sym ; symbol\n:void\n\n:thread\n:mutex\n\n:nil\n:atom\n\n:fn ; all callables\n:procedure\n:syntax\n\n:metaobj ; includes objects, classes, and interfaces\n:object\n:class\n:interface\n\n:dottable ; includes objects, classes, interfaces, and modules\n:module\n\n:port\n:inport\n:outport\n\n:type-alias\n\n### EScheme Collection Types\n\nCollection types represent an intrinsic EScheme collection type. By\ndefault, collections are just type-checked to match whatever type\nof collection the keyword stands for. However, collections may be\nparameterized by adding the `<type>` suffix in order to type-check\ntheir contents as well.\n\nFor example, `:list<str|sym>` is a list where each element is either\na string or symbol.\n\n- For either a list that only has strings OR a list that only has\n  symbols, use `:list<str>|list<sym>`.\n- Furthermore, `:pair` and `:map` may also be parameterized with the\n  `<type,type>` suffix in order to type-check their keys and values.\n\nEScheme's collection types include:\n\n:vec ; vector\n:map ; hashmap\n\n:pair\n:list\n\n:ac ; associative-collection (hashmaps, vectors, lists, strings)\n:oc ; ordered-collection (vectors, lists, strings)\n\n---\n\n## Type Syntax\n\nNotes on optional and variadic parameters:\n\n- Optional parameters only type-check user args, _not_ their default values\n  - Hence `(:int a \"hello\")` is a valid optional parameter clause\n- Variadic values cannot be typed (they're implicitly `:list<any>`)\n\n### `fn` and `defn`\n\n- `defn` uses the same type syntax as `fn`\n\n(fn\n  ; Typed <:int> return and <:list>/<:char> parameters\n  (:int (:list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Typeless return, required <:flo> parameter and optional <:int> parameter\n  ((:flo a (:int b 42))\n    (+ a b)))\n\n\n(defn function-name\n  ; Typed <:int> return and <:list>/<:char> parameters\n  (:int (:list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Typeless return, required <:flo> and optional <:int> parameters\n  ((:flo a (:int b 42))\n    (+ a b)))\n\n### `lambda`\n\n; Typed <:int> return and <:list>/<:char> parameters\n(lambda :int (:list a :char b . rest-args)\n  (length (cons b (cons a rest-args))))\n\n; Typeless return, required <:flo> and optional <:int> parameters\n(lambda (:flo a (:int b 42))\n  (+ a b))\n\n### `define`\n\n; Typed <:int> return and <:list>/<:char> parameters\n(define :int (function-name :list a :char b . rest-args)\n  (length (cons b (cons a rest-args))))\n\n; Typeless return, required <:flo> and optional <:int> parameters\n(define (function-name :flo a (:int b 42))\n  (+ a b))\n\n### `define-generator`\n\n- Only supports typed parameters, not typed returns, to account for\n  `*generator-complete*` being returned from finite generators.\n\n; Required <:flo> and optional <:int> parameters\n(define-generator (generator-factory-name :flo a (:int b 42))\n  (let loop ((i b))\n    (yield (+ i a))\n    (loop (+ i 1))))\n\n### `curry`\n\n- Only type-checks the return value once all parameters have been applied.\n\n; Typed <:int> return and <:list>/<:char> parameters\n(curry :int (:list a :char b)\n  (length (cons b a)))\n\n### `class`/`define-class` and `interface`/`define-interface`\n\n- `class` supports types on instance and static methods\n- `interface` only supports types on static methods\n- `define-class` uses the same type syntax as `class`\n  - as `define-interface` does with `interface`\n\n(define-class ClassName\n  ; Instance: typed <:int> return and <:list>/<:char> parameters\n  (:int (method-name-1 :list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Instance: typeless return, required <:flo> and optional <:int> parameters\n  ((method-name-2 :flo a (:int b 42))\n    (+ a b))\n\n  ; Static: typed <:int> return and <:list>/<:char> parameters\n  (:static :int (method-name-1 :list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Static: typeless return, required <:flo> and optional <:int> parameters\n  (:static (method-name-2 :flo a (:int b 42))\n    (+ a b)))\n\n\n(define-interface InterfaceName\n  ; Static: typed <:int> return and <:list>/<:char> parameters\n  (:static :int (method-name-1 :list a :char b . rest-args)\n    (length (cons b (cons a rest-args))))\n\n  ; Static: typeless return, required <:flo> and optional <:int> parameters\n  (:static (method-name-2 :flo a (:int b 42))\n    (+ a b)))\n\n\n; Mandating that <function-name> returns either <ClassName> or <InterfaceName>\n(define :ClassName|InterfaceName (function-name)\n  (ClassName))\n\n---\n\n## Type Aliases\n\nType aliases reference a preexisting keyword type, typically to\nmask type complexity. For example, when implementing a `UserProfile`\nclass, it might be nicer to define a `:phone-number` type instead of\nalways using `:str|list<int>`.\n\nType aliases can be created by using `define-type` (aliased by `deftype`).\nType alias primitive helper functions include:\n\n- `(type-alias? <obj>)` returns whether `<obj>` is a type alias\n- `(type-alias-source <type-alias>)` returns the original keyword type\n  that `<type-alias>` references\n\n### Example\n\n; Create a type-alias and dispatch on it\n(define-type phone-number :str|list<int>)\n\n(defn function-name\n  ((:phone-number x) #t)\n  ((:any x) #f))\n\n(function-name \"555-555-5555\") ; #t\n(function-name '(555 555 5555)) ; #t\n(function-name 5555555555) ; #f\n\n---\n\n## Type Primitive\n\n- `(type? <type-keyword>)` returns if `<type-keyword>` is a valid type\n- `(type? <obj> <type-keyword>)` returns if `<obj>` is a `<type-keyword>`\n- `(type=? <type-keyword> ...)` returns if `<type-keyword>`s are equivalent"
  }
]
