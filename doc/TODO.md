<!-- TODO.md -->

## MORE



[ ] WRITE LANGUAGE-WIDE UNIT TEST SUITE
    [X] FINISH WRITING TESTS FOR ALL PRIMITIVE FUNCTIONS
    [X] FINISH OTHER TESTS:
        [X] VARIABLES
        [X] SPECIALS
        [X] READER SYNTAX
        [X] OTHER MECHANICS (
            [X] e.g. "CALLING" VECTORS, STRINGS, HASHMAPS, FUNCTORS, ETC.
            [X] dot notation on objects and modules
            [X] reader lambda shorthand
    [X] INTEGRATE WAY TO LAUNCH SUCH 
        [X] `escm --unit-tests`, `escm -ut`
        [X] `java Installer --unit-tests`, `java Installer -ut`
            [X] ADD TO `README.md`, `help`, SOURCE-CODE INSTALLER COMMENTS, ETC. AS NEEDED
    [X] ___REVIEW ALL UNIT TESTS AGAIN TO MAKE SURE COVERING ALL CORNER CASES___
    [ ] _UPLOAD TO GITHUB THE FACT THAT WE HAVE UNIT TESTING_
        * MENTION ALSO (!!! THANKS TO THE UNIT TESTS !!!):
          [ ] FIXED IMPROPER ARG PROCESSING BY `with-output-to-file` AND `with-input-from-file`
          [ ] FIXED A BUG WHERE `string-split` WOULD NOT RETURN THE LAST CHARACTER IN THE STRING IF GIVEN NO "SPLITTER" 2ND ARG AND STRING DIDN'T END IN A 32BIT UNICODE
          [ ] CHANGED `string=?`, etc. JUST TO RETURN #t IF ONLY GIVEN 1 STRING. BEFORE, IT WOULD REQUIRE AT LEAST 2 ARGS. THIS NEW BEHAVIOR MAKES IT MORE LIKE `char=?`, etc.
          [ ] FIXED A MINOR JAVA BUG IN THE STRING-FORMATTER (e.g. for `stringf` etc.)
          [ ] UPDATED THE `help` DESCRIPTION FOR `meta-object` TO MENTION MODULES
          [ ] IMPROVED DEBUGGING MESSAGES FOR MACROS (NOW ALSO BINDS MACRO NAME TO INTERNAL CALLABLE [IF POSSIBLE] FOR MORE DETAILED ERROR MSGS)
          [ ] FIXED BUG W/ `move-file!` SOMETIMES FAILING TO PROPERLY CREATE INTERMEDIATE FILES
          [ ] IMPROVED `file-` PREFIXED PRIMITIVES TO IMPROVE INTERNAL JAVA ERROR REPORTING
          [ ] HAD SEVERAL THREAD PRIMTIIVES THAT USED TO THROW EXCEPTIONS NOW SIMPLY RETURN BOOLEAN SUCCESS STATUSES
          [ ] ADDED THE `*min-priority*` & `*max-priority*` GLOBAL VARIABLES
          [ ] FIXED BUG WHERE `read-line` WOULD FAIL GETTING THE LAST LINE OF INPUT-PORTS IF THEY DIDN'T END WITH A NEWLINE
          [ ] ADDED `help` ENTRIES FOR `char-lower-case?` AND `char-alphanumeric?` (MISSING BEFORE)
          [ ] ADDED IN `inexact->exact`, `exact->inexact`, `numerator`, `denominator`, `integral`, `fractional` PRIMITIVES
          [ ] ADDED IN `hashmap-val?` PRIMITIVE
          [ ] FIXED BUG WHERE `peek-port` WOULDN'T PROPERLY KEEP THE STREAM AT `#eof` AFTER `#eof` GETS INITIALLY DETECTED
          [ ] FIXED BUG WHERE `conj` WOULD ONLY SUPPORT 2 ARGS, NOW ALSO SUPPORTS 3
          [ ] UPDATED THE `number` DESCRIPTION IN THE `help` MENU
          [ ] FIXED AN ISSUE WHERE COMPLEX NUMBER LITERALS THAT USED INEXACT COMPONENTS WOULD SOMETIMES FAIL
          [ ] CLARIFIED INFINITY & NAN SEMANTICS IN ESCHEME'S NUMERIC TOWER
          [ ] CLARIFIED MUL & EXPT SEMANTICS FOR CORNER CASES WITH `0`, `1`, `Infinity`, `-Infinity`, `NaN`
          [ ] FIXED `gcd` & `lcm` BUG FOR INTEGER FLOATS
          [ ] FIXED `cos`, `asin`, `acos`, `acosh`, & `atanh` FOR COMPLEX NUMBERS
          [ ] FIXED `magnitude` FOR NEGATIVE REAL NUMBERS
          [ ] FIXED QUASIQUOTING NESTED SEMANTICS WHEN IMMEDIATELY NESTING `quasiquote` INSTANCES: E.G. `(quasiquote (quasiquote (unquote (+ 1 2))))`
          [ ] ELIMINATED FAULTY EXTRA ITEM GENERATED BY `stream->list`
          [ ] FIXED BUG WHERE `from` WOULD ONLY DETECT THE OPTIONAL SOURCE-PATH-STRING IF IT WAS A STRING LITERAL



[ ] DON'T ADDRESS THE BELOW IN ORDER: AFTER UNIT TESTS, RE-ORDER THE BULLETS BELOW TO GET THE MOST POSSIBLE FASTEST
    * OPTIMIZE FOR FIXING ANY MORE OUTSTANDING BUGS
      [ ] MODULES: FIX BUG WITH `expand-syntax` NOT EXPANDING MODULE MACROS CORRECTLY: `(display (expand-syntax '(lib.mac 8)))`
          [ ] ADD A UNIT TEST FOR THIS AFTER FIXING IT




[ ] CONSIDER EXPANDING `round` ETC. TO ACCEPT A 2ND `<precision-digits>` OPTIONAL ARG THAT DFLTS TO `0`
    [ ] UPDATE `help` & `primitives.md` & UNIT TESTS !!!!





[ ] RANDOM IDEA TO CONSIDER AFTER UNIT TESTS ARE DONE: SOMETHING LIKE `self`, BUT TO REFER TO THE MODULE WHERE THE SYMBOL WAS BOUND?
    => FIRST: SEE IPHONE NOTES REGARDING POSSIBLE ISSUES W/ THIS (ESP. IF WE CACHE MODULES W/IN MODULES)
    => suppose `this` represents what we're talking about:
       * `this.sym` ==
          1. get reader source file path of the `this` symbol
          2. check if we have a module with that path loaded
             a. if we do have that module, get `sym` from within that module
             b. else, get `sym` from the current env
       * reasoning (though unclear if this is [A] worth it &/or [B] will solve the issue &/or [C] what implications may arise):
         - helps solve issue of macros expanding to refer to internal functions from the module w/ the macro that a library importing the macro and referring to it won't have access to. e.g.:
   ```
   (define (f a) a)

   (define-syntax mac
    (lambda (x)
      (list 'f x))) ; error in importing module: f is not defined. Could this be fixed by referring to it as `this.f`?
   ```





[ ] CONSIDER AN `apply-super!` SPECIAL FORM:
    [ ] ADD TO HELP + UNIT TESTS AS NEEDED
  ```clj
  ; (apply-super! <param-list>)
  (define-syntax apply-super!
    (lambda (params-list) 
      (cons 'set! (cons 'super (list (list 'apply 'escm-oo-super! (list 'append '(list self) params-list)))))))
  ```



[ ] CONSIDER CHANGING ESCHEME'S INTERNAL ERROR MESSAGING SYSTEM TO USE THE INTERNAL `raise` MECHANISM, RATHER THAN THROWING A FATAL JAVA EXCEPTION
    [ ] => THIS COULD BE HUGE IF SO: COULD MASSIVELY SIMPLIFY CERTAIN ESCHEME CODE.
    [ ] => COULD ALSO RETURN `Exception` OBJECTS WITH DIFFERENT CLASSES MEANING DIFFERENT TYPES OF EXCEPTIONS
  ```clj
  ; Base Exception Class
  (define-class Exception 
    ((new error-message)
      (define self.str error-message)))

  ; Functional interface to access message (for those that don't want to use dot-notation & stay schemey)
  (define (exception->string e) e.str)


  ; Sample Use
  (define-class TypeException (:extends Exception)
    ((new fmt . args)
      (super! (apply stringf (cons fmt args)))))

  (define-class OddException (:extends Exception)
    ((new fmt . args)
      (super! (apply stringf (cons fmt args)))))


  (define (add-evens x y)
    (cond ((or (not (real? x)) (not (real? y))) 
            (raise (TypeException "'add-evens requires both args to be real even numbers: %w..." (list x y))))
          ((or (odd? x) (odd? y))
            (raise (OddException "'add-evens requires both args to be real even numbers: %w..." (list x y))))
          (else
            (+ x y))))


  (guard 
    (err
      ((TypeException? err) (displayf "Caught type-error: %a\n" err.str))
      ((OddException? err) (displayf "Caught odd-error: %a\n" err.str))
      (else (displayf "Caught unknown error: %a\n" err)))
    (displayf "%a\n" (add-evens 1 "2")))

  (guard 
    (err
      ((TypeException? err) (displayf "Caught type-error: %a\n" err.str))
      ((OddException? err) (displayf "Caught odd-error: %a\n" err.str))
      (else (displayf "Caught unknown error: %a\n" err)))
    (displayf "%a\n" (add-evens 1 2)))

  (guard 
    (err
      ((TypeException? err) (displayf "Caught type-error: %a\n" err.str))
      ((OddException? err) (displayf "Caught odd-error: %a\n" err.str))
      (else (displayf "Caught unknown error: %a\n" err)))
    (displayf "%a\n" (add-evens 2 4)))
  ```



[ ] TEST EFFECT (TIME SAVINGS) OF NOT MAINTAINING A CALL STACK FOR FCN CALLS. BASED ON RESULTS, CONSIDER HAVING THE CALLSTACK ACTIVE BY DEFAULT BUT OPT-OUTABLE VIA THE COMMAND LINE (& WITH AN ASSOCIATED GLOBAL BOOLEAN TO DETERMINE WHETHER CURRENTLY SAVING IT OR NOT)


[ ] HAVE SOMEWAY TO SET A TIME LIMIT ON A `system` CALL (TO PROTECT AGAINST LAUNCHING AN INFINITE-RUNNING PROGRAM)?


[ ] MENTION READER HASHMAP WART IN `help` (AND MAYBE OTHER DOCS?): SUPPOSE CLASS `c`, READER MAKES IT SO `{(c) 0 (c) 1}` ONLY YIELDS AN HMAP W/ 1 ITEM
    [ ] INSTEAD USE THE FUNCTION `(hashmap (c) 0 (c) 1)` TO GET THE EXPECTED RESULT


[ ] MAKE SURE IT IS CLEAR IN `help` DESCRIPTIONS THAT `define-class` (UNLIKE `class`) ALSO GENERATES A PREDICATE FUNCTION
    => E.G. `(define-class C)` GENERATES `C?`


[ ] EXPLAIN MODULE SEEKING SEMANTICS DURING IMPORTING BETTER IN `help`'s `import` & `module` SECTIONS, AS WELL AS IN `modules.md`


[ ] CONSIDER HAVING `help` PRINT TO CURRENT-STDOUT & READ FROM CURRENT-STDIN
    [ ] possible issue w/ this messing up line number count in the repl? maybe solve by opening a "help port" to the path of its relative "current" port version? or maybe this actually won't be an issue at all?


[ ] NOTE: `serialize` CURRENTLY LOADS THE FILE IN THE CURRENT ENV, BUT CONSIDER HAVING IT EVALUATED LIKE A MODULE BY DEFAULT?
    [ ] MAYBE HAVE ANOTHER PRIMITIVE TO DO THE CURRENT `serialize` PRIMITIVE'S LOGIC
        [ ] OR INSTEAD MAYBE HAVE `serialize-module`


[ ] CONSIDER OVERLOADING `+` AND `*` FOR `bind` AND `compose` RESPECTIVELY!


[ ] CONSIDER MENTIONING `#path` VARIABLE IN THE `(current-directory)` `help` DESCRIPTION:
    => IF YOU WANT THE CURR-DIR OF WHERE THE CURRENT PROCESS ORIGINATED, USE `(current-directory)`.
    => IF YOU WANT THE DIRECTORY OF THE CURRENT FILE THAT YOU'RE TYPING CODE IN, USE `#path`
       [ ] E.G. YOUR FILE MAY BE EXECUTED FROM ANOTHER DIRECTORY. 
           `(current-directory)` WILL BE THE DIRECTORY THAT YOU EXE'D THIS SCRIPT FROM, 
           WHILE `#path` WILL BE THE DIRECTORY OF THE SCRIPT ITSELF



[ ] CONSIDER CHANGING ARG ORDER FOR `display`, `write`, `pprint`, ETC. TO FLIP THE DATA & PORT ARGS (IN KEEPING WITH REGULAR SCHEME)



[ ] DEFINE SOME ESCM PRIMITIVE VERIABLE THAT IS THE CURRENT ESCM VERSION NUMBER (AS A STRING)



[ ] ADD IN PRIMITIVE `(path <string> ...)` EQUIVALENT TO:
    [ ] ADD UNIT TESTS FOR THIS & TO `primitives.md` & `help`
    [ ] CHANGE UNIT TESTS TO USE THE `path` FUNCTION WHEN LOADING THE `ut` MACRO
  ```clj
  (define (escm-path-has-terminal-separator? str)
    (define idx (string-contains-right str *file-separator*))
    (and idx (= (- (length str) idx) (length *file-separator*))))

  (define (escm-path-w/o-start-separator str)
    (define idx (string-contains str *file-separator*))
    (if (and idx (= idx 0)) (slice str (+ 1 idx)) str))

  (define (escm-path-w/o-terminal-separator str)
    (define idx (string-contains-right str *file-separator*))
    (if (and idx (= (- (length str) idx) (length *file-separator*)))
        (slice str 0 idx)
        str))

  (define (path str . strs)
    (unless (escm-path-has-terminal-separator? str)
      (set! str (append str *file-separator*)))
    (for-each 
      (lambda (s) 
        (set! s (escm-path-w/o-start-separator s))
        (set! str
          (if (or (empty? s) (escm-path-has-terminal-separator? s))
              (append str s)
              (append str s *file-separator*))))
      strs)
    (absolute-path (escm-path-w/o-terminal-separator str)))
  ```




[ ] CONSIDER A SYSTEM WRAPPER TO EXECUTE AN ESCHEME FILE:
    [ ] ADD UNIT TESTS FOR THESE & TO `primitives.md` & `help`
```clj
(define (escm script-file . argv)
  (if (null? argv)
      (system (append *escm-execution-command* script-file))
      (system 
        (apply
          append 
          (cons
            *escm-execution-command* 
            (cons 
              script-file
              (map (bind stringf " %a") argv)))))))
```


[ ] ADD A `when` MACRO:
    [ ] ADD TO UNIT-TESTS + `help` DOCUMENTS
```clj
(define-syntax when
  (lambda (condition . body)
    (list 'if condition
      (cons 'begin body))))
```



[ ] BYTECODE OPTIMIZATION: HAVE THINGS LIKE `(load 1) (push)` BECOME `(push 1)` 
    * may already be happening? check compiler logic/results
  
  - ___POTENTIAL ISSUE: WHAT IF A JUMP STATEMENT GOES IN THE MIDDLE OF A SERIES OF INSTRUCTIONS BEING REDUCED?___
    
    * MAYBE CONVERT: `(push <obj1>) (push <obj2>) ...` TO `(push-objs <obj1> <obj2> ...)`
      - Have an internal `Datum` Type that is just a thin shell (`Datum[]` around several objects)
    * CONVERT `(push <obj1>) ... (push <objN>) (call <N-as-integer-literal>)` TO `(call-objs <obj1> ... <objN>)`
    * NOTES: 
      - IN DOING THESE BYTECODE REDUCTION OPTIMIZATIZATIONS, MUST ADJUST `jump` AND `ifn` INSTRUCTION ARGUMENTS TO ACCOUNT FOR REDUCED INSTRUCTIONS
  ```sh
  bc := current bytecode block being assembled
  jmps := set of <pair>s, where <pair> := {instruction-idx, jump/byte <Instruction> object (need the <Instruction> object reference to also mutate <bc>)} # O(|bc|)
  n := |bc|
  for idx = 0; idx < n; idx := idx+1: # O(max(|bc|,|reductions|*|jmps|))
    if atStartOfBcReduction(bc,idx): # O(1)
      numberOfInstructionsEliminated := reduceBcInstance(bc,idx) # O(1)
      for each jmp in jmps: # O(|jmps|)

        # ISSUE: NEED TO ACCOUNT FOR HOW TO ADJUSTS JUMPING INTO THE MIDDLE OF THE REDUCTION
        #        > MAYBE JUST DON'T OPTIMIZE? CHECK TO SEE IF THIS WOULD HAPPEN B4 ACTUALLY DOING THE REDUCTION, ONLY REDUCE AFTER VALIDATING A) HAS VALID INSTRUCTIONS TO BE REDUCED, AND (B) WON'T BE BOTHERING ANY JUMPS (BUT ALSO NEED TO MK SURE THAT THS DOESN'T SLOW DOWN THE A9 TOO MUCH)

        if jmp.idx > idx && jmp.idx + jmps.offset < idx:
          jmps.offset := jmps.offset + numberOfInstructionsEliminated
        elif jmp.idx < idx && jmp.idx + jmps.offset > idx:
          jmps.offset := jmps.offset - numberOfInstructionsEliminated
        if jmp.idx > idx:
          jmp.idx := jmp.idx - numberOfInstructionsEliminated
      n := n - numberOfInstructionsEliminated


  # RUNTIME: O(|bc|) + O(max(|bc|,|reductions|*|jmps|))
  # => WORST CASE: |reductions| = |jmps| = |bc|/2 => RUNTIME := O(|bc|+(|bc|/2)**2)
  #    * Note that this 'worst case' is extrememly improbable.
  
  # => OPTIMIZATION: PERFORM THE BRANCH TRIMMING OPERATION (E.G. LIMITTING BRANCHES BEYOND THE LIMIT OF THE <bc> BLOCK) IN ONE OF THE ABOVE'S LOOPS

  # => OPTIMIZATION: MAYBE ELIMINATE <jmps>: HAVE 1 LOOP THAT COLLECTS <jmps> AS IT GOES __AND__ RECORDS PAST INFORMATION ON REDUCTIONS TO UPDATE FUTURE JUMPS AS ENCOUNTERED
  #                  E.G.:

    bc := current bytecode block being assembled
    jmps := [] # tracks <pair>s, where <pair> := {instruction-idx, jump/byte <Instruction> object (need the <Instruction> object reference to also mutate <bc>)} # O(|bc|)
    reductions := [] # tracks reduction start idxs, and the number of items eliminated
    n := |bc|
    for idx = 0; idx < n; idx := idx+1:
      if shouldGoInJmps(bc,idx): # O(1)
        jmps.push(bc[idx])
      elif atStartOfBcReduction(bc,idx): # O(1)
        numberOfInstructionsEliminated := reduceBcInstance(bc,idx) # O(1)
        reductions.push({idx,numberOfInstructionsEliminated})
        for each jmp in jmps:
          if jmp.idx + jmp.offset > idx:
            jmp.offset := jmp.offset - numberOfInstructionsEliminated





        for each pair in jmps: # O(|jmps|)
          if jmps[0] > idx && jmps[0] + jmps[1].jmpAmount < idx:
            jmps[1].jmpAmount := jmps[1].jmpAmount + numberOfInstructionsEliminated
          elif jmps[0] < idx && jmps[0] + jmps[1].jmpAmount > idx:
            jmps[1].jmpAmount := jmps[1].jmpAmount - numberOfInstructionsEliminated
          if jmps[0] > idx:
            jmps[0] := jmps[0] - numberOfInstructionsEliminated


        n := n - numberOfInstructionsEliminated


  ```
      - NOTE: JUST THE 2 ABOVE ALONE SEEM ABSOLUTELY WORTH IT FROM A BYTECODE COUNT PERSPECTIVE (THEY REDUCED THE BYTECODE COUNT OF COMPILING `quasiquote`'S PARSER BY `22%`), HOWEVER THE VM SHOULD BE TIMED TO VERIFY THIS REDUCTION ACTUALLY MAKES AN EXE-TIME DIFFERENCE IN ESCHEME CODE PERFORMANCE





[ ] IMPROVE ASCII ART AGAIN (specifically wording under the intro credit)!




[ ] UPDATE PPRINT TO ALSO WORK WITH VECTORS + HASHMAPS





[ ] SEE IPHONE NOTES





[ ] MAKE SURE ALL "Stream" & "File" & "Reader" & "Writer" INSTANCES ARE PROPERLY CLOSED IN JAVA
    * MAKE SURE MOVE AS MANY "CLOSE" OPERATIONS AS POSSIBLE PRIOR THROWING ERRORS FOR FILES!






[ ] CONSIDER CHANGING SYNTAX FOR READER SHORTHAND LAMBDAS FROM `\` TO `#`: `#(* %1 2)`
    * would make this more ide-friendly for existing scheme pkgs
    * Would only work if `#` is immediately followed by `(`?
      - maybe don't need this: if symbol sequence starts with `#`, see if it can make a valid literal prior converting to a lambda: e.g. `#t`, `#2r1`, `#\a`, etc.
    * UPDATE ALL EXISTING SCHEME CODE







[ ] ADD IN MORE SUPPORT FOR SELF-DOCUMENTING CODE
    [ ] => HAVE `help` LEVERAGE THIS!







====================================================================================
====================================================================================
====================================================================================
====================================================================================

- RUNTIME TYPING ___!!! THIS WOULD WARRANT A VERSION UPGRADE TO `10.0` (OR MAYBE `1.0.0`?) !!!___
  
  * CONSIDER BEING ABLE TO TAG DOCUMENTATION TO TYPES, THEN HAVING `help` SEARCH THIS LIST DYNAMICALLY GET THE VARIOUS `help` ENTRIES ON ESCHEME TYPES?

  * CHECK TO MAKE SURE ALL TYPES ARE BEING ENCAPSULATED

  * NOTE: THE BELOW SHOULD ALSO BE AVAILABLE FOR CLASS METHODS !!!
    - GO THRU OTHER SPECIAL FORMS AND SEE WHERE ELSE COULD BE USED !!!

  * CONSIDER: `(define-type <keyword> <unary-predicate-callable>)` `(type? <keyword>)` `(delete-type! <keyword>)` `(type-predicate <keyword>)`

  BASICS: `(def :string (f (:string s) (:any a)))` use keywords to denote basic type checks
                ^           ^           ^
            return value   string       any-type!

          ***NOTE:*** SUPPORT FALSE-ABLE TYPES (SIMILAR TO NULLABILITY) VIA: `:string?`
          
          ARBITRARY PREDICATE TYPING: `(def (g (:type even? arg-name)))` `:type <predicate?-fcn>` => check validity of arg based on predicate. ALSO SUPPORT FALSABLE `:type?`

          ```scheme
          ;; OR MAYBE INSTEAD:

          (define-type <keyword> <procedure>)
          ```

          COULD THEN HAVE:
            ```scheme
            (defn fun
              (:list ((:string s)) (list s)) ; !!! can dispatch on type !!!
              (:integer ((:number n)) n))
            ```

          NEW LAMBDA SYNTAX: `(lambda <return-type> (<parameter> ...) <body>)`
          NEW FN SYNTAX:     `(fn (<return-type> (<parameter> ...) <body> ...))`
          NEW DEFINE SYNTAX: `(define <return-type> (<procedure-name> <parameter> ...) <body> ...)`
            => `<parameter>` ::= `<type-keyword> <name-symbol>` `(<type-keyword> <name-symbol> <default-value>)`
                                                                  ^
                                                                  will NOT check the type of the `<default-value>`, ONLY new bound args

          ***!!! MUST COMPARE FCN CALL SPEEDS IN HOT LOOPS TO VERIFY THIS DOENSN'T CRIPPLE US !!!***

          PRIMTIIVE TYPES (REMEMBER TO MAKE FALSEABLE `:<name>?` ALTERNATIVES TO EACH OF THE BELOW AS WELL):
            ```scheme
            :number
            :integer
            :real
            :complex
            :exact
            :inexact

            :string
            :keyword
            :boolean
            :symbol
            :void

            :vector
            :hashmap

            :thread
            :mutex

            :nil
            :pair
            :list
            :atom

            :procedure
            :callable
            :functor
            :syntax

            :meta-object
            :object
            :class
            :interface

            :port
            :input-port
            :output-port

            :ac ; :associative-collection
            :oc ; :ordered-collection

            :module
            ```

====================================================================================
====================================================================================
====================================================================================
====================================================================================







- CONSIDER A BREAKPOINT-SETTING FCN/SPECIAL FORM/INSTRUCTION TO HELP WITH DEBUGGING?
  * `(breakpoint <optional-string-descriptor>)`
    => ONLY ACTUALLY BREAKS IF RUNNING THE INTERPRETER IN `-d`, `--debug` MODE 
       => ADD TO BOTH `README` & `command-line` SECTION IN `help`

    => ENTERS IN A `debug>` MENU (similar to `help`)
       => ENABLE SAFE QUERYING OF ENVIRONMENT VALUES
       => IF GIVEN `<optional-string-descriptor>`, PRINT A PREAMBLE TO THE `debug>` PROMPT TO SAY `debug> BREAKPOINT REACHED: <optional-string-descriptor>`
          - ALSO INCLUDE THE FILE/LINE/COL DATA STORED FROM THE `<breakpoint>` SYMBOL IN THE `debug>` PREAMBLE

       * MAYBE EFFECTIVELY LAUNCH A REPL IN THE CURRENT ENVIRONMENT THAT, ONCE QUIT OUT OF VIA `#eof`, RESUMES EXECUTION OF THE CURRENT ESCM SESSION FROM WHERE PAUSED
         => NOTE THAT USERS MAY ENTER `(exit)` IN THE BREAKPOINT MENU TO TERMINATE ALL OF ESCM'S EXECUTION

  * ADD IN PRIMITIVE VARIABLE `*debug*` => SET THIS TO WHETHER GIVEN `-d`, `--debug` FLAG @ CMD-LINE

  * ADD IN A PRIMTIIVE `(call-stack)` FUNCTION THAT RETURNS A LIST OF THE CURRENT CALL-STACK (FUNCTION NAMES ARE STRINGS) 
    => CONSIDER HOW TO ALSO RETURN DATA ABOUT SOURCE INFO IF AVAILABLE?
       * RETURN AN ALIST THAT STARTS WITH THE FCN NAM EIN THE CALLSTACK, FOLLOWED BY A LIST (OR NIL) HOLDING DOURCE FILENAME, NEWLINE INTEGER, & COLUMN LINE INTEGER





  



[ ] ADD JSON SUPPORT PRIMITIVES
    => `json->scm`, `scm->json`, `object->json`, `json-datum?`, `json-string?`
    => USE HASHMAPS AND VECTORS AS APPROPRIATE

[ ] ADD CSV SUPPORT PRIMITIVES









- GENERATE DETAILED DOCUMENTION FOR `README.md` AUTOMATICALLY VIA THE `help` ENTRIES !!!
  * should also generate internal links correctly !!!











[ ] FROM THE CMD LINE USING `escm` AS A CMD:
    [ ] BOOT SCRIPTS STORED IN A FILE NAMED "`.escm-boot-scripts`"
    [ ] ALLOW THE ADDING OF NEW FILES TO ESCM'S SET OF FILES TO LOAD UP UPON AN INITIAL ESCM PROGRAM LAUNCH
        (BASICALLY JUST A WAY FOR USERS TO ADD THEIR OWN "stdlib"S TO BE LOADED UPON UPON BOOT-TIME)
        `$ escm -bs-ls,  --boot-script-list`
        `$ escm -bs-mk,  --boot-script-make <filename> ...` // moves `<filename>` to the end of the boot-script list if it already exists (can't have 1 file 2+ times)
        `$ escm -bs-rm,  --boot-script-remove <filename> ...` // returns whether successfully deleted all of them.
        `$ escm -bs-s,   --boot-script-swap <src-filename> <dest-filename>` // put `<src>` into `<dest>`'s position, & `<dest>` into `<src>`'s if `<src>` already exists
        `$ escm -bs-e,   --boot-script-exists <filename> ...` // returns whether each filename is a boot script (`#t` vs `#f`)
        `$ escm -bs-cat, --boot-script-concatenate <filename>` // appends all of the boot-script entries in `<filename>` to the current boot-script list.
        [ ] ALSO HAVE A WAY TO DO THIS PROGRAMATICALLY:
            `(boot-script-list)`
            `(boot-script-make! <filename-str> ...)`
            `(boot-script-remove! <filename-str> ...)`
            `(boot-script-swap! <src-filename-str> <dest-filename-str>)`
            `(boot-script-exists? <filename-str> ...)`
            `(boot-script-concatenate! <filename-str>)`
    [ ] HENCE IN THE INSTALL JAVA SCRIPT:
        `$ escm --serialize-stdlib`
        `$ escm --boot-script-make ../bin/stdlib.ser`










- AFTER RUNTIME TYPING, CONSIDER RUNTIME ACCESS MODIFIERS FOR OBJECTS (NOTE THAT `:public` MUST BE ___FAST___ !!!)








[ ] have anonymous lambdas print some unique id for slightly easier debugging

[ ] CONSIDER OPTIONAL SUPPORT FOR ANSI COLORS!
    * have a flag to disable these
    * NOTE: ERRORS/WARNINGS MIGHT BE ABLE TO GET AWAY WITH USING EMOJIS INSTEAD
    * `-n`, `--nansi`

[ ] CHECK WHETHER SHOULD ALWAYS SET LOCAL TO ENGLISH OR NOT WHEN RUNNING ESCM (DOING SO PROGRAMMATICALLY)









[ ] ADD IN MORE DIVERSE/COMPLEX SAMPLE FILES TO THE `doc/example` DIRECTORY







- NETWORKING PRIMITIVES

- WEB SERVER CREATION PRIMITIVES

- GUI PRIMITIVES
  * GET TO THE POINT WHERE CAN GENERATE A FRACTAL
  * CONSIDER A -i, --interactive FLAG TO LAUNCH THE REPL IN A GUI WINDOW THAT DETECTS KEYSTROKES, STORES HISTORY VIA ^v, ETC. 

- LOGIC PROGRAMMING FUNCTIONS

- LOOK BACK AT HEIST-SCHEME FOR ANY OTHER FEATURES TO IMPLEMENT

- CHECK IPHONE `ESCM TODOS` NOTE